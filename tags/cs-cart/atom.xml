<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: cs-cart | 8xx8 (Андрей Кулаков)]]></title>
  <link href="http://8xx8.ru/tags/cs-cart/atom.xml" rel="self"/>
  <link href="http://8xx8.ru/"/>
  <updated>2017-12-14T00:16:50+07:00</updated>
  <id>http://8xx8.ru/</id>
  <author>
    <name><![CDATA[Andrey Kulakov (8xx8)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CS-Cart 3.0: Динамические объекты в менеджере блоков]]></title>
    <link href="http://8xx8.ru/blog/2012/05/24/cs-cart-3-dot-0-dinamichieskiie-obiekty-v-mieniedzhierie-blokov/"/>
    <updated>2012-05-24T13:51:00+07:00</updated>
    <id>http://8xx8.ru/blog/2012/05/24/cs-cart-3-dot-0-dinamichieskiie-obiekty-v-mieniedzhierie-blokov</id>
    <content type="html"><![CDATA[<p>Динамический объект в менеджере блоков &ndash; это любой объект карты для которого можно сменить контект какого-либо блока и его статус, на детальной странице этого объекта.</p>

<!-- more -->


<p>В стандартной поставке уже определены 5 видов динамических объектов, это Продукты, Страницы, Категории, Компании (только для редакции Multivendor), Новости.</p>

<h2>Прикладное значение</h2>

<p>Рассмотрим данный функционал на примере продуктов, потому как для всего остального это будет работать схожим образом.</p>

<p>На странице редактирования продукта, при изменении контента блока, он будет сохраняться именно для этого продукта, причём затем при редактировании контента этого же блока, снизу будет отображаться информация о том, где контент был изменён и дополнительный чекбокс, установив который можно применить изменённый контент глобально.</p>

<p>Так же при включении/выключении блока на странице редактирования продутка, его состаняние будет сохраняться именно для этого продукта.</p>

<p>В менеджере блоков на локации с dispatch=products.view, при редактировании любого блока, у него есть дополнительная вкладка Status, на которой можно задать для каких-либо продуктов статус отличный от установленного по умолчанию, т.е. включить блок где-то, если он выключен глобально и наоборот.</p>

<h2>Принцип работы</h2>

<p>Функционал динамических объектов реализуется в блок менеджере автоматически по средствам описания объекта в схеме dynamic_objects, по этому при желании можно дополнить эту схему в своём аддоне любым дополниительным объектом, как например расширяет общую схему аддон News &amp; Emails.</p>

<p>Описание схемы на примере продуктов:</p>

<p>```php
&lt;?php
array(
  // Название динамического объекта, будет использоваться в качестве object_type
  &lsquo;products&rsquo; => array (</p>

<pre><code>// Страница редактирования динамического объекта, на которой должна отобразиться вкладка Blocks в административной части сайта
'admin_dispatch' =&gt; 'products.update',

// Адрес страницы на которой в клинтской зоне и в панели управления блоками будет доступна работа с динамическим объектом
'customer_dispatch' =&gt; 'products.view',

// Ключ в $_REQUEST по которому будет определяться идентификатор объекта
'key' =&gt; 'product_id',

// Настройки пикера, который будет использоваться в административной части сайта
'picker' =&gt; 'pickers/products_picker.tpl',
'picker_params' =&gt; array (
  'type' =&gt; 'links',
),
</code></pre>

<p>  ),
)
```</p>

<p>Когда пользователь запрашивает, напрмер, страницу с <code>dispatch=products.view</code>, то магазин определяет, что эта страница принадлежит динамическому объекту products и ищет в пришедших в скрипт параметрах product_id. Если такой находится, то все данные для генерации страницы будут запрошены через API блоков с указанием соответствующего типа и идентификатора, если не был по диспатчу найден тип блока в схеме или ключевой параметр, то данные будут генерироваться без учёта динамического объекта, то есть выведется всё со значениями установленными глобально.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Схема блоков в CS-Cart 3.0]]></title>
    <link href="http://8xx8.ru/blog/2012/04/17/skhiema-blokov-v-cs-cart-3-dot-0/"/>
    <updated>2012-04-17T10:48:00+07:00</updated>
    <id>http://8xx8.ru/blog/2012/04/17/skhiema-blokov-v-cs-cart-3-dot-0</id>
    <content type="html"><![CDATA[<p>Менеджер блоков в Cs-cart 3.0 достаточно сложная штука. И я хотел бы сделать попытку
объяснить как все таки с ним работать.</p>

<!-- more -->


<h2>Файлы</h2>

<ul>
<li><strong>block_cache_properties.php</strong> — глобальные апдейт хендлеры для кеша блоков;</li>
<li><strong>dispatch_descriptions.php</strong> — список диспатчей и соответсвтующих лангвар. Нужно только
для генерации списка для поля Dispatch при добавлении/редактировании локации;</li>
<li><strong>blocks.php</strong> &ndash; основная схема блоков;</li>
<li><strong>dynamic_objects.php</strong> — описание динамических объектов;</li>
<li><strong>fillings.php</strong> — дополнительные параметры для филингов;</li>
<li><strong>templates.php</strong> — дополнительные параметры лдя шаблонов.</li>
</ul>


<h2>Основая схема</h2>

<p>```php
  &lsquo;тип блока&rsquo; => array (</p>

<pre><code>'settings' =&gt; 'Список настроек (а)',
'templates' =&gt; 'Список шаблонов (б)',
'content' =&gt; 'Список контента (в)',
'wrappers' =&gt;' Список враперов (г)',
'icon' =&gt; 'Путь до иконки',
'cache' =&gt; 'Параметры кеша, если отсутствует, то блок не кешируется.'
</code></pre>

<p>  );
```</p>

<p><em>а)</em> Сам блок может иметь настройки которые будут задаваться на странице редактирования
блока в панели администрирования на вкладке settings, так же настройки могут иметь шаблоны
и филлинги. на странице редактирвоания блока они все отображаются в разных местах, но в
итоге хранятся в массиве properties блока и к ним можно получить доступ из шаблона. Так же
они передаются в функцию получения списка элементов для перечисляемого типа.</p>

<p>Список настроек предсьтавляет сабой набор пар типа ключ => значение, где ключём будет имя
настройки. Оответсвтенно этому имени должна быть определена языковая переменная которая
определяет название при выводе этой настройки.</p>

<p>Значемнием будет массив параметров определяющих эту настройку:</p>

<p>```php
&lsquo;имя_настройки&rsquo; => array(</p>

<pre><code>'remove_indent'   =&gt; 'Если истинно, то при отображении в админке у настройки не будет отступа справа'
'required'        =&gt; 'Если истинно, то в настройках блока поле будет обязательно для заполнения'
'option_name'     =&gt; 'Имя языковой переменной для названия, если не задано в качестве него будет использоваться имя_настройки'
'default_value'   =&gt; 'Значение по умолчанию'
'values'          =&gt; 'Список вариантов настройки. Массив пар ключ =&gt; значение для настроек типа selectbox, multiple checkboxes'
'no_lang'       =&gt; 'Если истинно, то при отображении в админке у списка вариантов занчение варианта будет выводится как есть, иначе интерпретирвоанться как языковая переменная'
'values_settings' =&gt; 'Применяется только с настройкой типа selectbox. В этом параметре задаётся список вариантов и дополнительные настройки, которые будут появлятся только при выборе определённыз вариантов родительского списка. В качестве примера см. схему блока аддона Rss Feed.'
'picker'        =&gt;' Шаблон пикера. Применяется только с типом настройки picker.'
'picker_params'   =&gt; 'Настройки пикера. Применяется только с типом настройки picker.'
'template'        =&gt; 'Путь к шаблону. применятеся только с типом настройки "template"'
</code></pre>

<p>  );
```</p>

<p><strong>Типы настроек:</strong></p>

<ul>
<li><strong>checkbox</strong> — гuалочка;</li>
<li><strong>input</strong> — поле ввода;</li>
<li><strong>input_long</strong> — поле ввода с классом input-text-long;</li>
<li><strong>multiple_checkboxes</strong> — список галочек;</li>
<li><strong>text</strong> — поле ввода текса типа WYSIWYG;</li>
<li><strong>simple_text</strong> — обычное поле ввода текста без WYSIWYG;</li>
<li><strong>picker</strong> — пикер;</li>
<li><strong>template</strong> — шаблон. Вместо сеттинги будет тоображаться тот шаблон, который указан в
параметре template;</li>
<li><strong>enum</strong> — перечесление объектов. Используется только в секци content</li>
</ul>


<p><em>б)</em> Список шаблонов может быть:</p>

<p>```php
  &lsquo;путь<em>к</em>шаблону&rsquo; => array (</p>

<pre><code>'settings' =&gt; 'Список настроек (см. ниже)',
'fillings' =&gt; 'Массив из филлингов которые доступны для этого шаблона (все сотальные филлинги будут автоматически исключены из списка)',
'params' =&gt; 'Массив параметров, которые будут переданы в функцию получения элементов блока',
'bulk_modifier' =&gt; 'Групповой модификатор. Функция которая применится к элементам блока перед выводом'
</code></pre>

<p>  ),
```</p>

<p>Всё что есть в параметре &lsquo;template&rsquo; в схеме блоков будет объединено с параметрами
заданными в схеме templates.php, при генерации схемы, ключём является путь к шаблону.</p>

<p>Соответственно по ключу &lsquo;template&rsquo; в схеме блоков может быть:</p>

<ul>
<li><em>А)</em> Список путей к шаблонам с непосредственно полным переченем параметров, в таком
случае не потребуется ничего писать в templates.php;</li>
<li><em>Б)</em> Список путей к шаблонам, а все параметры по соотвествующим ключам указаны в
templates.php;</li>
<li><em>В)</em> Путь к папке с шаблонами, а все параметры по соотвествующим ключам указаны в
templates.php;</li>
<li><em>Г)</em> Название функции которая возвращает список шаблонов, а все параметры по
соотвествующим ключам указаны в templates.php или так же возвращаются функцией.</li>
</ul>


<p><em>в)</em> В новом блок менеджере любой блок может содержать произвольное колличество переменных
которые затем передадуться в шаблон, например имея такой блок:</p>

<p>```php
  &lsquo;test_block&rsquo; => array (</p>

<pre><code>'content' =&gt; array(
  'some_value' =&gt; array(
    'type' =&gt; 'text',
  )
)
</code></pre>

<p>  )
```</p>

<p>В настроках блока в панели администрирования появится поле ввода в которое можно ввести
значение. При отображении блока в кастомерке в шаблоне этого блока будет доступна
переменная <code>{$some_value}</code> значение которой задано в админке.</p>

<p>В качестве элемента контента может быть любая настройка (см. пункт натсроек), специальный
тип перечисление (<code>enum</code>), функция.</p>

<p>С настройками всё просто, то что пользователь сохранит в админке то и пойдёт в шаблон.</p>

<p>Тип перечисление нужен для того чтобы определять списки элементов с различными видами
заполнения (<code>fililng</code>), например список продуктов или категорий.</p>

<p>Параметры типа <code>enum</code>:</p>

<p>```php
  &lsquo;имя_переменной&rsquo; => array (</p>

<pre><code>'type' =&gt; 'enum',
'object' =&gt; 'Название динамического объекта в схеме.'
'items_function' =&gt; 'Функция генерации элементов'
'fillings' =&gt; array ( // Филлинги, т.е. типы заполнения.
  'manually' =&gt; array ( // Ручной тип. Требует наличия параметров пикера.
    'picker' =&gt; 'pickers/companies_picker.tpl',
    'picker_params' =&gt; array (
      'multiple' =&gt; true,
    ),
  ),
  'some_another_filling' =&gt; array (
    'params' =&gt; array (

    ),
  ),
),
</code></pre>

<p>  ),
```</p>

<p>Для неручного филлинга можно задать секцию params в которой будет список теъх параметров
который в итоге будет передан в функцию генерации элементов, так же для филлинга можно
задать список настроек по ключу settings, аналогично шаблонам или самим блокам.</p>

<p>Если в качестве элемента контента используется функция, то значение этой переменной будет
равно результату который вернёт эта функция. Формат определяни таков:</p>

<p><div><script src='https://gist.github.com/2783014.js?file=function.php'></script>
<noscript><pre><code>&lt;?php
	&#39;имя_переменной&#39; =&gt; array (
		&#39;type&#39; =&gt; &#39;function&#39;,
		&#39;function&#39; =&gt; array(&#39;fn_get_languages&#39;[, &#39;param1&#39;][, &#39;param2&#39;][..]),
	),</code></pre></noscript></div>

```php
  &lsquo;имя_переменной&rsquo; => array (</p>

<pre><code>'type' =&gt; 'function',
'function' =&gt; array('fn_get_languages'[, 'param1'][, 'param2'][..]),
),
</code></pre>

<p>```</p>

<p><em>г)</em> В параметре wrapeprs как и в шаблонах может быть либо список враперов, либо путь к
папке с ними. дополнительные настройки у них отсутствуют.</p>

<p><em>д)</em> Если блок должен быть кешируемым то нужно определить ему свойство cache в схеме. В
котором по ключу update_handlers перечислить список таблиц, при обновлении которых будет
обновляться кэш.</p>

<p>В новом менеджере блоков все те статические блоки объединены в так называемый блок
template у коготорого есть только одно свойство  template в котором можно выбрать
какой-либо шаблон для отображения из папки blocks/static_templates. Если вам нужно именно
такой блок, то в аддоне достаточно создать папку blocks/static_templates и разместить там
свой шаблон, который автоматичнски добавится к остальным. В принципе этот способ
распространяется для всех основных блоков карты, расширить список их шаблонов можно по
средствам добавления соотвествующей папки в аддоне.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Резиновый магазин]]></title>
    <link href="http://8xx8.ru/blog/2012/03/20/riezinovyi-maghazin/"/>
    <updated>2012-03-20T12:35:00+07:00</updated>
    <id>http://8xx8.ru/blog/2012/03/20/riezinovyi-maghazin</id>
    <content type="html"><![CDATA[<p>Начиная с версии CS-Cart 3.0 используется новая философия блоков и блок менеджера в частности.</p>

<p>Ключевым моментом здесь является использование CSS фреймворка 960gs (сайт проекта <a href="http://960.gs">http://960.gs</a>).</p>

<!-- more -->


<p>Данный фреймворк предназначен для быстрой, эффективной и кроссбраузерной вёрски веб-контента по модульной сетке размером 960 пикселей с разделением на 12 или 16 колонок.</p>

<p>В нашем случае модульная сетка нужна для того что бы можно было безпрепятственно создавать любую структуру для размещения блоков на любой странице.</p>

<p>К сожалению данный потход в виду своей гибкости с одной стороны имеет ограничение, ширина контента страницы получается фиксированной.</p>

<p>Решить эту проблему мужно используя другой CSS файл определяющий правила для классов фреймворка.</p>

<p>Есть такой проект <a href="http://www.designinfluences.com/fluid960gs/">http://www.designinfluences.com/fluid960gs/</a> в нём реализовано как раз возможность растягивания лэйаута по ширине.</p>

<p>Для того что бы подключить у себя на сайте, нужно заменить скачать файл <a href="https://raw.github.com/bauhouse/fluid960gs/master/css/grid.css">https://raw.github.com/bauhouse/fluid960gs/master/css/grid.css</a> с репозитория проекта и заменить оригинальный файл карты your_skin_path/customer/css/960/960.css на скачанный.</p>

<p>Но при использовани такого потхода возможна проблема из-за большой вложенности с шириной в процентах, например grid_10 внутри grid_10 будет брать процент от ширины родителя, а не фиксированную как в стандартном 960.gs изза этого вложенный грид будет чуть меньше.</p>

<p>Для того чтобы это исправить можно вручную добавить вложенным гридам нужную ширину, а родительскому гриду установить content-aligment full-width.</p>

<p>На примере стандартной шапки cs-cart это будет выглядеть так:</p>

<p>```css
  html .helper-container .full-width {</p>

<pre><code>width: 100%;
</code></pre>

<p>  }
  html .helper-container .top-links-grid {</p>

<pre><code>width: 98.0%;
</code></pre>

<p>  }
  html .helper-container .search-block-grid {</p>

<pre><code>width:54.25%;
</code></pre>

<p>  }
  html .helper-container .cart-content-grid {</p>

<pre><code>width:41.75%;
</code></pre>

<p>  }
```</p>

<p>Тем же способом можно подключать файлы созданные с помощю сервиса <a href="http://grids.heroku.com/">Grids</a>. Он позволяет создавать сетку различной фиксированной длинны.</p>
]]></content>
  </entry>
  
</feed>
