<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: git push | 8xx8 (Андрей Кулаков)]]></title>
  <link href="http://8xx8.ru/tags/git-push/atom.xml" rel="self"/>
  <link href="http://8xx8.ru/"/>
  <updated>2017-12-15T17:33:28+07:00</updated>
  <id>http://8xx8.ru/</id>
  <author>
    <name><![CDATA[Andrey Kulakov (8xx8)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Будь ленив и быстр. Git]]></title>
    <link href="http://8xx8.ru/blog/2013/11/12/bud-lieniv-i-bystr-git/"/>
    <updated>2013-11-12T12:32:00+07:00</updated>
    <id>http://8xx8.ru/blog/2013/11/12/bud-lieniv-i-bystr-git</id>
    <content type="html"><![CDATA[<p><code>
cat ~/.zsh_history | wc -c
431403
</code></p>

<p>Столько символов я использовал, набирая различные команды в консоли.</p>

<p>Не знаю как вам, а я думаю, это много. Даже если учесть, что половину из этого занимают
пути к файлам и части, дополненные автокомплитом, это все равно много. Статистика взята
примерно за 4 месяца, и если выкинуть выходные и прикинуть, получается около 6000 знаков в
день. Пара страниц формата А4. Большая часть этого труда – это  рутинные команды или
последовательности типичных действий.</p>

<p>Как ни странно, но это одна из немногих ситуаций в жизни, когда можно делать минимум, а
результата получать максимум.</p>

<!-- more -->


<p>Помогут в этом знания полезных программ, приготовленные в функции и автодополнения,
поданные под нужным соусом из псевдонимов. Но путь ленивых и быстрых не для новичков.
Существует опасность получить «алиас головного мозга» или «расстройство
отсутствия плагина», совершено забыв о том, что где-то в недрах вашего блюда есть то,
что имеет совершенно другую начинку.</p>

<p>Погружение на темную сторону можно разделить на несколько частей. Согласно сложности
реализации и абстрагированности от реальной жизни.</p>

<h2>Git</h2>

<p>Не секрет, что <code>git</code> обладает продвинутым и гибким интерфейсом командной строки, но эта
гибкость достигается дорогой ценой, а именно многословностью. В результате для
выполнения некоторых простых действий требуется вводить немалое количество слов в
командной строке.</p>

<p>На этапе знакомства с системой это даже хорошо, помогает вникнуть. Но
в повседневной работе набирать раз за разом небольшой эпос в командной строке,
когда, например, нужно посмотреть только diff определенного коммита, тяжело.</p>

<h3>Полезные опции</h3>

<p>Эти мелочи могут выручить всегда, даже если вашего <code>dotfiles</code> не будет рядом.</p>

<p><code>git log --oneline</code> — Вывести лог в одну строку.</p>

<p><code>git add -u</code> — Добавить в stage все, кроме файлов, находящихся вне git.</p>

<p><code>git status -s</code> — Прагматичный статус без лишней информации.</p>

<p><code>git branch --merged</code> — Ветки слитые в текущую.</p>

<p><code>git branch --no-merged</code> — Ветки не слитые в текущую.</p>

<h3>Базовые сокращения</h3>

<p>```
cp = cherry-pick
st = status -s
cl = clone
ci = commit
co = checkout
br = branch</p>

<p>sl = stash list
sa = stash apply
ss = stash save</p>

<p>```</p>

<h3>Diff</h3>

<p>Изменения, приготовленные к коммиту (staged)</p>

<p><code>
dc = diff --cached
</code></p>

<p>Изменения в последнем коммите</p>

<p><code>
dlc = diff --cached HEAD^
</code></p>

<p>Изменения в определенном коммите (<code>git dr dcee010</code>)</p>

<p><code>
dr  = "!f() { git diff "$1"^.."$1"; }; f"
</code></p>

<h3>Push / Pull</h3>

<p>Применение изменений из векти так, чтобы все наши коммиты шли после</p>

<p><code>
up = pull --rebase
</code></p>

<p>Отправление только текущей ветки</p>

<p><code>
put = push origin HEAD
</code></p>

<h3>Коммит</h3>

<p>Отмена последнего коммита с сохранением состояния stage</p>

<p><code>
undo = reset --soft HEAD^
</code></p>

<p>Добавить все файлы в stage к последнему коммиту, не котрывая редактор
с сообщением</p>

<p><code>
aps = commit --amend -C HEAD
</code></p>

<p>Определить нахождение коммита</p>

<p><code>
where = branch -av --contains
</code></p>

<h3>Красивый лог</h3>

<p><code>
lg = log --pretty=format:\"%h %Cblue%ar %Cgreen%an%Creset: %s %Cred%d\"
ll = log -10 --pretty=format:\"%h %Cblue%ar %Cgreen%an%Creset: %s %Cred%d\"
gr = log --graph --pretty=format:\"%Cred%h %Cblue%ar%Creset %Cgreen%an%Creset %s%Cred%d\"o
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Все или не все? (git push)]]></title>
    <link href="http://8xx8.ru/blog/2013/06/12/git-vsie-ili-nie-vsie/"/>
    <updated>2013-06-12T13:45:00+07:00</updated>
    <id>http://8xx8.ru/blog/2013/06/12/git-vsie-ili-nie-vsie</id>
    <content type="html"><![CDATA[<p>Часто ли вы задумывались над тем, какие ветки будут отправлены в
удалённый репозиторий при выполнении команды <code>push</code>?</p>

<p>А поможет ли вам задуматься над этим такая картина?</p>

<p><img src="/images/content/force-push/1.png" title="[]" ></p>

<p>Наверное, поможет, особенно если увидеть это в ночь перед релизом. А
началось-то все с того, что хотели фичу красиво слить через rebase.</p>

<p>Так давайте разберёмся, что пошло не так.</p>

<!-- more -->


<p>Гит пушит всё. Да, вы не ослышались. По умолчанию это так и есть. Беседы
о том, что поведение по умолчанию не безопасное оставим за кадром
и найдём решение.</p>

<p>```
$ git push &mdash;help</p>

<pre><code>   git push [--all | --mirror | --tags] [-n | --dry-run]
</code></pre>

<p>[&mdash;receive-pack=&lt;git-receive-pack>]</p>

<pre><code>              [--repo=&lt;repository&gt;] [-f | --force] [--prune] [-v |
</code></pre>

<p>&mdash;verbose] [-u | &mdash;set-upstream]</p>

<pre><code>              [&lt;repository&gt; [&lt;refspec&gt;...]]
</code></pre>

<p>```</p>

<p>Как видно из документации, мы можем пропустить указание назначения(repository) и refspec (конструкция вида ЛОКАЛЬНАЯ<em>ВЕТКА[:][УДАЛЁННАЯ</em>ВЕТКА]), по умолчанию в качестве назначения будет использовано origin, а в качестве refspec будет использована одна из стратегий определённых в настройке <code>push.default</code>. Она может принимать такие значения:</p>

<ul>
<li><code>nothing</code> &ndash; не пушить ничего</li>
<li><code>matching</code> &ndash; пушить все ветки, названия которых в локальном
репозитории
совпадают с названиями в удалённом репозитории.
<em>Это как раз та опция, которая используется, если ничего не задано</em></li>
<li><code>upstream</code> &ndash; пушить только текущую ветку в ту ветку на удалённом
репозитории, которая прописана в конфиге как upstream</li>
<li><code>tracking</code> &ndash; устаревший синоним для <code>upstream</code></li>
<li><code>current</code> &ndash; пушить только текущую ветку в ту ветку на удалённом
репозитории с которой совпадёт имя</li>
</ul>


<p>Самый лучший способ решить проблему – это указывать repository и refspec всегда при выполнении команд <code>push</code>/<code>pull</code>.</p>

<p>Либо полностью:</p>

<p><code>
git push origin branch:branch
</code></p>

<p>Либо в качестве refspec использовать HEAD:</p>

<p><code>
git push origin HEAD
</code></p>

<p>В таком случае текущая ветка будет запушена в ветку с таким же названием
в удалённом репозитории.</p>

<p>Можно сделать псевдоним для команды, чтобы было удобнее</p>

<p><code>
git config --global alias.put 'git push origin HEAD'
</code></p>

<p>Есть и другой способ. Изменить поведение по умолчанию при пуше. Но у
такого подхода есть существенный минус. Как минимум можно привыкнуть к
тому, что система ведёт себя по другому и в том месте, где она настроена
не так как у вас или забыв при смене системы настроить её, можно опять
попасть в ситуацию как на картинке в начале статьи.</p>

<p><code>bash
git config --global push.default upstream
</code></p>
]]></content>
  </entry>
  
</feed>
